'LM 2576': 'to263 <[ Vin Out Gnd Feedback on/off ]>'
R1206: '''
  # From http://www.resistorguide.com/resistor-sizes-and-packages/
  r1206 =
      a: 1.6mm
      b: 0.9mm
      c: 2mm
  
  {a, b, c} = r1206
  
  p1 = pad b, a
  p2 = p1.clone!
      ..position.x += (c + b) |> mm2px
  
'''
'find-test': '''
  # --------------------------------------------------
  # all lib* scripts will be included automatically.
  # --------------------------------------------------
  find-pin "c1", 5
      ..pad.selected = yes
  
  
'''
lib_to263: '''
  to263 = (pin-labels) ->
      # From: http://www.ti.com/lit/ds/symlink/lm2576.pdf
      dimensions = d =
          H   : 14.17mm
          die : x:8mm     y:10.8mm
          pads: x:2.16mm  y:1.07mm
          pd  : 1.702
  
      p1 = pad 1, d.die
          ..data.aecad.label = pin-labels.0
  
      padg = group()
      for index, pin of [1 to 5]
          pad pin, d.pads, padg
              ..position.y -= index * mm2px d.pd
              ..data.aecad.label = pin-labels[index]
  
      padg.position =
          d.H |> mm2px
          p1.bounds.height / 2
          
  
'''
'proxy-test': '''
  
  x = pad 1, {x: 10, y: 20}
  y = ComponentProxy x
  y.on-set 'position', (val) ->
      console.log "Doing MITM for position: ", val
      [null, val]
  y.position += [10, 20]
  
'''
lib_ComponentProxy: '''
  class ComponentProxy
      (main) ~>
          if main 
              @main = that 
          @__handlers = {}
          for let key of @main
              type = typeof! @main[key]
              if type is \\Function 
                  @[key] = @main[key]
              else
                  #console.log "Defining property: #{key}", type
                  Object.defineProperty @, key, do
                      get: ~>
                          @main[key]
      
                      set: (val) ~>
                          if @__handlers[key]?
                              [err, res] = @__handlers[key] val
                              unless err
                                  @main[key] = res
                          else
                              @main[key] = val
  
      on-set: (prop, handler) ->
          @__handlers[prop] = handler
  
  
  /*
  y = new ComponentProxy new Group
  y.on-set 'position', (val) ->
      console.log "Doing MITM for position: ", val
      [null, val]
  y.position += [10, 10]
  */
'''
lib_pads: '''
  # --------------------------------------------------
  # all lib* scripts will be included automatically.
  #
  # This script will also be treated as a library file.
  # --------------------------------------------------
  
  
  # Pad
  # -----------------------------------
  # Usage: 
  #
  #   .position: Position 
  #
  
  pad = (pin-number, dimensions, parent) ->
      rect = new Rectangle do 
          from: [0, 0]
          to: dimensions |> mm2px
          
      _group = new Group do 
          position: rect.center
          parent: parent or g 
          data:
              aecad:
                  pin: pin-number
          applyMatrix: yes
          
      cu = new Path.Rectangle do
          rectangle: rect
          fillColor: 'purple'
          parent: _group
          stroke-width: 0
          data:
              aecad:
                  pin: pin-number
  
      ttip = new PointText do
          point: cu.bounds.center 
          content: pin-number
          fill-color: 'white'
          parent: _group
          font-size: 3
          position: cu.bounds.center
  
      return _group
  
  
'''
'class-approach-test': '''
  clone = (x) -> JSON.parse JSON.stringify x
  
  getBase = (_pads, based-on) -> 
      pads = clone _pads
      base = {}
      if based-on 
          base <<<< pads[that]
      if base.is 
          # base also depends on another one 
          base <<<< pads[that]
      return base 
  
  # Footprint is effectively a Group item 
  class Footprint
      (data) -> 
          # create main container 
          @g = new Group do
              applyMatrix: no
              data: 
                  aecad: 
                      type: \\Footprint
                    
          @pads = {}
          for pad, params of data.pads
              base = getBase data.pads, params.is
              #console.log "initializing pad: #{pad} base: ", base
              @pads[pad] = new Pad @g, (base <<<< params) 
  
          @_data = {} # resolved data 
          for pad, params of data.pads
              base = getBase data.pads, params.is
              @_data[pad] = (base <<<< params)  
              console.log "resolved pad: #{pad}:", @_data[pad]
              
              
          # set positions 
          /* 
           * x, y (center coordinates of bounds)
           * top, bottom, left, right
           * 
           */
          /*
          for name, pad of data.pads
              console.log "#{name} position: "
              for dir, pos of (pad.opts.position or {})
                  # @.foo means pads.base.foo
                  # TODO: throw error if pad.opts.is is null
                  pos = pos.replace /^@\\./, "pads.#{pad.opts.is}."
                  # @bar.baz means pads.bar.baz
                  pos = pos.replace /^@/, 'pads.'
                  console.log "...#{dir} pos: ", pos
          */
                  
  
  
      position: ~
          -> @g.position
          (val) -> @g.position = val
          
      color: ~
          (val) ->
              for k, pad of @pads 
                  pad.color = val
          
      
  class Pad
      (parent, @opts) -> 
          dimensions = 
              x: @opts.width 
              y: @opts.height 
              
          rect = new Rectangle do 
              from: [0, 0]
              to: dimensions |> mm2px
              
          @g = new Group do 
              position: rect.center
              parent: parent
              data:
                  aecad:
                      pin: opts.pin
              applyMatrix: yes
              
          @cu = new Path.Rectangle do
              rectangle: rect
              fillColor: 'purple'
              parent: @g
              stroke-width: 0
  
          @ttip = new PointText do
              point: @cu.bounds.center 
              content: @opts.pin
              fill-color: 'white'
              parent: @g
              font-size: 3
              position: @cu.bounds.center
              
          for <[ left right top bottom center ]>
              Object.defineProperty @, .., do
                  get: ~> @g.bounds[..]
              
      position: ~
          -> @g.position
          (val) -> @g.position = val 
          
      color: ~
          (val) -> @cu.fillColor = val
          
  
  fp = new Footprint do 
      pads: 
          pad1:
              pin: 1
              width: 4
              height: 8
              label: \\there 
          pad2: 
              is: \\pad1
              pin: 2
              width: 8
              label: \\hello
              position:
                  x: '@.left + 40'
          pad3: 
              is: \\pad2
              position: 
                  y: '@.bottom + 30'
  
          pad4: 
              is: \\pad2
              position: 
                  y: '@pad1.bottom + 30'
                  
          /*
          for: '1 to 5':                 
              "pad{index}": 
                  is: "pad{index - 1}"
                  pin: "{index}"
          */
  
  fp.color = 'red'
  #console.log "pad3 left: ", fp.pads.pad3.position
  
  
'''