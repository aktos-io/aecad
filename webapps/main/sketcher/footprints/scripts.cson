'LM 2576': 'to263 <[ Vin Out Gnd Feedback on/off ]>'
R1206: '''
  # From http://www.resistorguide.com/resistor-sizes-and-packages/
  r1206 =
      a: 1.6mm
      b: 0.9mm
      c: 2mm
  
  {a, b, c} = r1206
  
  p1 = pad b, a
  p2 = p1.clone!
      ..position.x += (c + b) |> mm2px
  
'''
'find-test': '''
  # --------------------------------------------------
  # all lib* scripts will be included automatically.
  # --------------------------------------------------
  find-pin "c1", 5
      ..pad.selected = yes
  
  
'''
lib_to263: '''
  to263 = (pin-labels) ->
      # From: http://www.ti.com/lit/ds/symlink/lm2576.pdf
      dimensions = d =
          H   : 14.17mm
          die : x:8mm     y:10.8mm
          pads: x:2.16mm  y:1.07mm
          pd  : 1.702
  
      p1 = pad 1, d.die
          ..data.aecad.label = pin-labels.0
  
      padg = group()
      for index, pin of [1 to 5]
          pad pin, d.pads, padg
              ..position.y -= index * mm2px d.pd
              ..data.aecad.label = pin-labels[index]
  
      padg.position =
          d.H |> mm2px
          p1.bounds.height / 2
          
  
'''
'proxy-test': '''
  
  x = pad 1, {x: 10, y: 20}
  y = ComponentProxy x
  y.on-set 'position', (val) ->
      console.log "Doing MITM for position: ", val
      [null, val]
  y.position += [10, 20]
  
'''
lib_ComponentProxy: '''
  class ComponentProxy
      (main) ~>
          if main 
              @main = that 
          @__handlers = {}
          for let key of @main
              type = typeof! @main[key]
              if type is \\Function 
                  @[key] = @main[key]
              else
                  #console.log "Defining property: #{key}", type
                  Object.defineProperty @, key, do
                      get: ~>
                          @main[key]
      
                      set: (val) ~>
                          if @__handlers[key]?
                              [err, res] = @__handlers[key] val
                              unless err
                                  @main[key] = res
                          else
                              @main[key] = val
  
      on-set: (prop, handler) ->
          @__handlers[prop] = handler
  
  
  /*
  y = new ComponentProxy new Group
  y.on-set 'position', (val) ->
      console.log "Doing MITM for position: ", val
      [null, val]
  y.position += [10, 10]
  */
'''
lib_pads: '''
  # --------------------------------------------------
  # all lib* scripts will be included automatically.
  #
  # This script will also be treated as a library file.
  # --------------------------------------------------
  
  
  # Pad
  # -----------------------------------
  # Usage: 
  #
  #   .position: Position 
  #
  
  pad = (pin-number, dimensions, parent) ->
      rect = new Rectangle do 
          from: [0, 0]
          to: dimensions |> mm2px
          
      _group = new Group do 
          position: rect.center
          parent: parent or g 
          data:
              aecad:
                  pin: pin-number
          applyMatrix: yes
          
      cu = new Path.Rectangle do
          rectangle: rect
          fillColor: 'purple'
          parent: _group
          stroke-width: 0
          data:
              aecad:
                  pin: pin-number
  
      ttip = new PointText do
          point: cu.bounds.center 
          content: pin-number
          fill-color: 'white'
          parent: _group
          font-size: 3
          position: cu.bounds.center
  
      return _group
  
  
'''
'class-approach-test': '''
  
  # Container is effectively a Group
  class Container
      (parent) -> 
          # parent: parent object or initialization data 
          # if in {init: ...} format
          @pads = []
          init-with-data = no 
          if parent and \\init of parent
              init = parent.init
              parent = null 
              if init
                  init-with-data = yes 
                  #console.log "Container init:", init
                  @g = init
                  for @g.children
                      #console.log "has child: ", (Type ..data)
                      type = ..data?aecad?type
                      @pads.push switch type
                      | \\Container =>
                          new (Type ..data)({init: ..})
                      | \\Pad => 
                          new (Type ..data) do
                              init:
                                  parent: this 
                                  content: ..
                      |_ => throw new Error "What type is this? #{type}"
  
  
          unless init-with-data
              # create main container 
              @g = new Group do
                  applyMatrix: no
                  parent: parent?g
              parent?add this
      
              @g.data = 
                  aecad: 
                      type: @constructor.name
  
      position: ~
          -> @g.position
          (val) -> @g.position = val
          
      color: ~
          (val) ->
              for @pads 
                  ..color = val
                  
      print-mode: ~
          (val) -> 
              for @pads 
                  ..print-mode = val 
  
      add: (item) !-> 
          @pads.push item
  
      rotate: (angle) -> 
          # rotate this item and inform children 
          @rotation = angle 
          @g.rotate angle 
          for @pads
              ..rotated? angle 
              
      rotated: (angle) -> 
          for @pads
              ..rotated? angle 
              
      mirror: (state) -> 
          @g.scale -1, 1
          x = @g.bounds.center
          @g.rotate (180 + 2 * @rotation), @g.bounds.center
          @g.bounds.center = x  # this is interesting, I'd expect no need for this     
          for @pads 
              ..mirrored? state
              
      mirrored: (state) -> 
          for @pads 
              ..mirrored? state
  
  
  cross = new class CanvasHelper extends Container 
      -> 
          super!
          new Path.Line do
              from: [-50, 0]
              to: [50, 0]
              stroke-color: \\white
              parent: @g
              
          new Path.Line do
              from: [0, -50]
              to: [0, 50]
              stroke-color: \\white
              parent: @g
              
          @g.opacity = 0.5
          
      print-mode: ~
          (val) -> @g.visible = not val
  
  class Footprint extends Container 
      (data) -> 
          # data: 
          #   name: required 
          #   position: optional
          #   rotation: optional 
          #   init: current drawing
          super {init: data.init}
          unless data.init
              # initialize from scratch
              @data = 
                  type: @constructor.name
                  
              @data <<<< data
          else
              # initialize with provided data 
              @data = data.init.data.aecad
              
          @g.data = aecad: @data
          
  class Pad
      (parent, opts) -> 
          # opts: 
          #     # Required 
          #     pin
          #     width 
          #     height 
  
          init-with-data = no 
          if parent and \\init of parent
              init = parent.init
              parent = null 
              if init
                  init-with-data = yes 
                  #console.log "Pad init:", init
                  @g = init.content
                  @parent = init.parent
                  for @g.children
                      # get cu, ttip etc.
                      part = ..data.aecad.part
                      @[part] = ..
                      
  
          # declare Pad.left, Pad.top, ...
          for <[ left right top bottom center ]>
              Object.defineProperty @, .., do
                  get: ~> @g.bounds[..]
  
          unless init-with-data
              @parent = parent 
              @opts = opts 
              
              if @opts.width and @opts.height 
                  geometry = \\Rectangle
                  dimensions = 
                      x: @opts.width |> mm2px
                      y: @opts.height |> mm2px
                      
                  rect = new Rectangle do 
                      from: [0, 0]
                      to: dimensions 
                      
                  geo-params = {rectangle: dimensions}
      
              else if @opts.dia
                  geometry = \\Circle
                  x = @opts.dia |> mm2px 
                  dimensions = 
                      radius: x / 2
                      x: x 
                      y: x 
      
                  rect = new Rectangle do 
                      from: [0, 0]
                      to: [x, x]
                      
                  geo-params = {radius: dimensions.radius}
                  
                  
              aecad-data = 
                  type: @constructor.name
                  
              aecad-data <<< @opts 
              
              @g = new Group do 
                  position: rect.center
                  parent: @parent.g
                  data:
                      aecad: aecad-data
                  applyMatrix: yes
                  
              @parent.add this 
              
              @cu = new Shape[geometry] geo-params <<< do
                  rectangle: rect
                  fillColor: 'purple'
                  parent: @g
                  stroke-width: 0
                  data: aecad: part: \\cu
                  
              if @opts.drill
                  @drill = new Path.Circle do 
                      radius: (@opts.drill / 2) |> mm2px
                      fillColor: canvas.style.background
                      parent: @g
                      position: @cu.position 
                      stroke-width: 0
                      data: aecad: part: \\drill
      
              @ttip = new PointText do
                  point: @cu.bounds.center 
                  content: @opts.pin
                  fill-color: 'white'
                  parent: @g
                  font-size: 3
                  position: @cu.bounds.center
                  justification: 'center'
                  data: aecad: part: \\ttip
                  
              @ttip.bounds.center = @cu.bounds.center
          
              
      position: ~
          -> @g.position
          (val) -> @g.position = val 
          
      color: ~
          (val) ->
              @_color = val 
              @cu.fillColor = @_color
          
      clone: (opts={}) ->
          new @constructor @parent, (@opts <<<< opts)
          
      print-mode: ~
          # Switch to print mode 
          -> @_print
          (val) -> 
              @_print = val
              if @_print
                  # switch to print mode 
                  @drill?.fillColor = \\white 
                  @ttip.visible = false
                  @cu.fillColor = \\black
              else 
                  @drill?.fillColor = canvas.style.background 
                  @ttip.visible = true
                  @cu.fillColor = @_color
                  
      rotated: (angle) -> 
          @rotation = angle 
          @ttip.rotate -angle
          @ttip.bounds.center = @cu.bounds.center
          
      mirrored: (state) -> 
          console.warn "TODO: set text rotation correctly"
  
  
  fp = new Footprint do 
      name: 'foo'
      
  pad1 = new Pad fp, do
      pin: 1
      width: 5
      height: 15
  
  c = new Container fp
  
  for index in [1 to 5]
      pad = new Pad c, do 
          pin: index
          width: 1
          height: 2
  
      pad.position.y -= 16 * index
      
  c.position = pad1.position
  c.position.x += 23
  
  c2 = new Container fp
  
  for index in [1 to 5]
      pad = new Pad c2, do 
          pin: "#{index}c"
          dia: 3
          drill: 1
  
      pad.position.y -= 16 * index
  
  c2.position = c.position
  c2.position.x += 10
  
      
  #fp.color = 'red'
  #fp.rotate 45
  #fp.g.rotate -45
  x = find-comp 'foo'
  <~ sleep 1000ms
  x.rotate -45
  #x.selected = yes
  #console.log x.toJSON()
      
  #fp.mirror!
  #fp.print-mode = yes 
  
  
'''
lib_find: '''
  Type = (data) -> 
      name = data?aecad?type or data
      if name.match /^[a-zA-Z0-9_]+$/
          eval name
      else
          throw new Error "Who let the dogs out?"
  
  find-comp = (name) !-> 
      for project.layers
          for ..getItems()
              if ..data?aecad?name is name
                  type = ..data?aecad?type
                  Type = eval type
                  return new Type do 
                      name: name 
                      init: ..
      return null     
  
  find-pin = (name, pin) !->
      _find = (item) !->
          if item.hasChildren!
              for item.children
                  if _find ..
                      return that
          else if pin and item.data?aecad?pin is pin
              return item
          return null 
  
      container = find-comp name 
      pad = _find container
      return {container, pad}
  
'''